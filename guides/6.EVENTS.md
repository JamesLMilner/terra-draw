# Events

Terra Draw has a number of ways to interact with it, including:

- Responding to native mouse/pointer Events
- Responding to Terra Draw Events

## Native Events

### Getting Features From A Mouse/Pointer Event

Getting features at a given mouse event can be done like so:

```typescript
document.addEventListener("mousemove", (event) => {
  const featuresAtMouseEvent = draw.getFeaturesAtPointerEvent(event, {
    // The number pixels to search around input point
    pointerDistance: 40,

    // By default polygons are only considered at the location if they are directly selected
    // this option allows them to be returned if they are within the pointer distance 
    includePolygonsWithinPointerDistance: true,

    // Ignore features that have been selected
    ignoreSelectFeatures: true,

    // ignore coordinates
    ignoreCoordinatePoints: true,

    // Ignore the current feature if one is being drawn
    ignoreCurrentlyDrawing: true,

    // Ignore closing points 
    ignoreClosingPoints: true,

    // Ignore snapping points 
    ignoreSnappingPoints: true,

    // Adds to feature's properties information about the closest coordinate to pointer event
    addClosestCoordinateInfoToProperties: true

  });

  // Do something with the features...
  console.log({ featuresAtMouseEvent });
});
```

### Getting Features At A Given Longitude/Latitude

Getting features at a given longitude and latitude can be done like so:

```typescript
map.on("mousemove", (event) => {
  const { lng, lat } = event.lngLat;
  const featuresAtLngLat = draw.getFeaturesAtLngLat(
    { lng, lat },
    {
      // The number pixels to search around input point
      pointerDistance: 40,

      // Ignore features that have been selected
      ignoreSelectFeatures: true,
    },
  );
  console.log({ featuresAtLngLat });
});
```

> [!NOTE]
> The second argument is optional for both `getFeaturesAtPointerEvent` and `getFeaturesAtLngLat`, with defaults set to `ignoreSelectFeatures: false` and `pointerDistance: 30`.

### Ignoring Mismatched Targets For Pointer Down/Up Events 

By default in Terra Draw, if you put the pointer down outside and of the map element and then release inside it, the `onClick` callback will still be called for the current mode. For example if you are in TerraDrawPointMode, you put the pointer down outside the map element (say a sidepanel) then release the inside the map element, it will trigger the onClick event in the point mode and create a point. You can avoid this by passing `ignoreMismatchedPointerEvents: true` to your adapter. This will mean onClick would not get called in this scenario and not point would be created.


## Terra Draw Events

There are a number of Terra Draw events that you can listen to. For example, you can add a callback function that is invoked when Terra Draw has completed editing a Feature:

```typescript
draw.on("change", (ids, type) => {
  //Done editing
  if (type === "delete") {
    // Get the Store snapshot
    const snapshot = draw.getSnapshot();

    // Do something
    //...
  }
});
```

If you are interested if the event was triggered by the Terra Draw API (i.e. `addFeatures`, `removeFeatures`), there is a third optional parameter ('context') that will have a property called origin, which is of type `api` if it has come from the API.


```typescript
draw.on("change", (ids, type, context) => {
  //Done editing
  if (type === 'change') {
    if (context?.origin === 'api') {
      console.log('this was changed via the API!')
    } else if (context?.origin === undefined) {
      console.log('this change did not originate from the API!')
    }
  }
});
```

You can check if properties or geometry was updated for the features in question by checking the `target` property of the context:

```typescript
draw.on("change", (ids, type, context) => {
  if (type === 'change') {
    if (context?.target === 'properties') {
      console.log('properties were changed')
    } else if (context?.target === 'geometry') {
      console.log('geometry was changed')
    }
  }
});
```

The other Terra Draw events are:

```typescript
draw.on("finish", (id: string, context: { action: string, mode: string }) => {
  if (context.action === 'draw') {
    // Do something for draw finish event
  } else if (context.action === 'dragFeature') {
    // Do something for a drag finish event
  } else if (context.action === 'dragCoordinate') {
    //
  }else if (context.action === 'dragCoordinateResize') {
    //
  }
});

draw.on("change", (ids: string[], type: string) => {
  // Possible type values:
  // 'create'
  // 'update'
  // 'delete'
  // 'styling'
  // Do something
  //...
});

draw.on("select", (id: string) => {
  // Do something
  //...
});

draw.on("deselect", () => {
  // Do something
  //...
});
```

# Store Change Events

 The "change" event types that are emitted by the store "delete", "create", "update", "styling". Context can also be passed with these events, which can be used to determine the origin of the event and the type of update. The context is an object that can have the following properties: `origin`, `target` and `updateType`. The `origin` property can be "api" or not set to imply internal changes that are generally originating from user actions. The `target` property can be "geometry" or "properties". The `updateType` property should only be passed when the change type is "update", the possible can be "provisional", "commit" or "finish". Here is an overview of the 3 `updateType` emitted:

- "provisional" updates are those that are not yet committed too, such as a scenario where the pointer is moved whilst drawing and having a provisional point that follows the cursor. Similarly if a point was dragged, but the pointer is not yet released this would also be considered provisional. "provisional" is essentially any update which is not yet committed too and could change again shortly. 

- "commit" updates are those that are made when an interaction is completed, such as adding a point whilst drawing, or when the pointer is released after dragging a point, or scaling a feature but there are still further updates to come before the feature is considered finished. 

- "finish" updates are those that are made when an interaction is completed and the changes to the feature are finalized for the current session of interactions. For example, when drawing a polygon and the user clicks to add the final point and complete the polygon, this would be a "finish" update. Similarly, if a feature is being scaled and the user releases the pointer and there are no further updates to be made to the feature, this would also be a "finish" update.

---

**Guides**

1. [x] [Getting Started](./1.GETTING_STARTED.md)
2. [x] [Store](./2.STORE.md)
3. [x] [Adapters](./3.ADAPTERS.md)
4. [x] [Modes](./4.MODES.md)
5. [x] [Styling](./5.STYLING.md)
6. [x] Events
7. [ ] [Development](./7.DEVELOPMENT.md)
8. [ ] [Examples](./7.EXAMPLES.md)
