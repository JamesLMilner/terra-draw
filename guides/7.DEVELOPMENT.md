# Development

How to develop the Terra Draw project locally.

## Prerequisites

You will need to have the following installed:

- [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
- [Node.js v22.x](https://nodejs.org/en/download/)
- [npm v10.x](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

## Folder Structure

- `.devcontainer` - GitHub development container related code
- `.github` - used for all GitHub related configuration such as the GitHub Actions work flows
- `.husky` - used to storing the precommit hooks that are used on the project
- `packages` - source files for the packages in this project
- `dist` - the bundled distributed files of the project
- `docs` - the built API docs that is published to GitHub pages
- `guides` - learn how to use Terra Draw

## Conventional Commits and Precommit Hooks

It is probably useful to be aware of the precommit hooks you will face when trying to run a git commit on the project. There are two currently in use, namely:

- Uses pre-commit hook to run lint rules (eslint/prettier) on code before commit.
- Uses pre-commit hook to ensure [conventional commit messages](https://www.conventionalcommits.org/en/v1.0.0/) are used.


For the conventional commit precommit hook, you will need to follow the convention provided in the `commitlint` config of the root package.json. This currently enforces the standard types (`feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `build`, `ci`, `chore`, `revert`), along with the package names as the scope.

Here's some example of some valid commits:

* `feat(terra-draw): some commit message relating to the core Terra Draw library`
* `feat(terra-draw-openlayers-adapter): some commit relating specifically to OpenLayers adapter package`
* `feat(terra-draw-leaflet-adapter): some commit relating specifically to Leaflet adapter package`

In conventional commits, you can use the `!` to indicate a breaking change like so:

* `feat(terra-draw)!: some breaking change commit message relating to the core Terra Draw library`

This will increment the major version on release, i.e. v1.0.0 -> v2.0.0. `feat` will trigger a minor release update, i.e. v1.0.0 -> v1.1.0 and `fix` will trigger a patch, i.e. v1.0.0 -> v1.0.1.

>[!NOTE] 
> The library used to write the CHANGELOG and bump the appropriate package on release, `commit-and-tag-version` is not able to correctly recommend the correct version when bumping the package. Instead we work around this using the `bump.mjs` script which accurately determines what the new package version should be, based on the conventional commit specification. It then passes this `commit-and-tag-version` via the `--release-as` flag which allows you to specifically set the release version.

## Technologies Used

- [TypeScript](https://www.typescriptlang.org/) - provides strong compile time typing for JavaScript
- [Jest](https://jestjs.io/) - used for testing (see more information below)
- [Storybook.js](https://storybook.js.org/) - way to quickly showcase different Terra Draw configurations
- [microbundle](https://github.com/developit/microbundle) - used for the production bundle

## Building the Terra Draw Packages

To build the project, you will need to install the dependencies from the project root:

```shell
npm install
```

You will also need to then install in the package you are interested in building. Let's go to the folder and then install in there too:

```shell
cd packages/terra-draw
npm install
```

Then we can run the following to build that specific package:

```shell
npm run build
```

## Adapter Interface

In theory, an adapter could be created for any mapping library that can fill out the Adapter abstract class (`TerraDrawBaseAdapter`).

For example, in the `LeafletAdapter` we create and update a GeoJSON layer that Leaflet knows how to render to the screen.

Assuming that an adapter extends from `TerraDrawBaseAdapter`, these methods would need to be implemented:

```typescript
public project(...args: Parameters<Project>): ReturnType<Project>;

public unproject(
  ...args: Parameters<Unproject>
): ReturnType<Unproject>;

public setCursor(
  ...args: Parameters<SetCursor>
): ReturnType<SetCursor>;

public getLngLatFromEvent(event: PointerEvent | MouseEvent): {
  lng: number;
  lat: number;
} | null;

public setDraggability(enabled: boolean): void;

public setDoubleClickToZoom(enabled: boolean): void;

public getMapEventElement(): HTMLElement;

public render(
  changes: TerraDrawChanges,
  styling: TerraDrawStylingFunction
): void;
```

You can see a very basic example adapter in the `terra-draw.extensions.spec.ts` file. It shows how you can create your own adapter from the publicly exposed library imports.

## Mode Anatomy

Modes are not just limited to drawing features, for example the built-in `TerraDrawSelectMode` allows for selection and editing of geometries that have previously been drawn. The `TerraDrawRenderMode` is a "view only" Mode useful for showing non-editable data alongside editable data in your application.

Assuming that a mode extends from `TerraDrawBaseMode`:

```typescript
/** @internal */
start() {
  this.setStarted();
}

/** @internal */
stop() {
  this.setStopped();
}

/** @internal */
onClick(event: TerraDrawMouseEvent) {}

/** @internal */
onMouseMove(event: TerraDrawMouseEvent) {}

/** @internal */
onKeyDown(event: TerraDrawKeyboardEvent) {}

/** @internal */
onKeyUp(event: TerraDrawKeyboardEvent) {}


/** @internal */
onDragStart(event: TerraDrawMouseEvent) {}

/** @internal */
onDrag(event: TerraDrawMouseEvent) {}

/** @internal */
onDragEnd(event: TerraDrawMouseEvent) {}

/** @internal */
styleFeature(feature: GeoJSONStoreFeatures): TerraDrawAdapterStyling {}
```

You can see a very basic example mode in the `terra-draw.extensions.spec.ts` file. It shows how you can create your own mode from the publicly exposed library imports.

## Testing

Terra Draw uses [Jest](https://jestjs.io/) as its testing framework. You can distinguish a test by its `.spec.ts` file name extension.

To run the tests as they would run in CI:

```shell
npm run test
```

You can also check the coverage by running:

```shell
npm run test:coverage
```

If coverage (either lines, branches, functions or statements) falls under 80%, this script will fail.

For local development you may benefit from the `nocheck` option which allows you to avoid running TypeScript type checking when running the tests. This option also only checks files which are explicitly tested (i.e. have a spec file.)

```shell
npm run test:nocheck
npm run test:nocheck:coverage
```

## Developing Locally with Storybook

One of the simplest way to start developing locally is in the `packages/storybook` folder. This package is based off  Storybook.js. It can allow you to quickly visualise and test different Terra Draw configurations. The development tooling for Storybook.js is designed to respond in real time to changes in the source via hot module reloading. The stories (you can think of them as examples) provided should give you a good starting point for experimenting with Terra Draw. The project runs the Storybook build and test steps on CI to help ensure the integrity of both the Terra Draw Storybook implementation and Terra Draw more broadly.

Please see the README in the `packages/storybook` folder for further instructions on how to get started.

## End-to-End Testing

There are End-to-End tests that run on PR in CI (GitHub Actions). These can be seen in the `packages/e2e` folder. They are currently based on the Leaflet Adapter as this exposes elements in the DOM that can be expected. If you are adding features or making significant changes, please consider adding to or updating the E2E test suite to ensure the integrity of the library and your changes.

## API Docs

API Docs are automatically generated from [TSDoc](https://tsdoc.org/) comments in the codebase, using the [TypeDoc library](https://typedoc.org/). If you are editing library code, please write/update the TSDoc comments with useful and correct information with the changes. You can regenerate the API docs running:

```
npm run docs
```

If you want to view them locally you can do this using the `docs:serve` script which spins up a simple web server and serves the static API docs locally:

```
npm run docs:serve
```

## Contributing

If you wish to contribute to Terra Draw, we request that you:

1. Make an issue on GitHub describing the bug you intend to fix or the feature you intend to add.
2. Create a fork of the project, and work on a branch that represents the issue.
3. Ensure that the work you have done is unit tested, aiming for 80% code coverage.
4. Create a PR that represents this work with a [conventional commit](https://www.conventionalcommits.org/en/v1.0.0/#summary) title (this ensures the automated changelog is generated correctly). Please refer to the issue from the PR and follow the PR template. 
5. We will address the PR and give you feedback.

Please note that we can not guarantee that all PRs will be merged. There are cases where a PR may deviate from the long-term vision for Terra Draw and hence we may have to decline it. Creating the issue in advance helps us discuss any potential issues upfront before the PR is made.

## Code of Conduct

We have a code of conduct which we expect individuals interacting with the project to respect. Please refer to the full [Code of Conduct](./CODE_OF_CONDUCT.md).

---

**Guides**

1. [x] [Getting Started](./1.GETTING_STARTED.md)
2. [x] [Store](./2.STORE.md)
3. [x] [Adapters](./3.ADAPTERS.md)
4. [x] [Modes](./4.MODES.md)
5. [x] [Styling](./5.STYLING.md)
6. [x] [Events](./6.EVENTS.md)
7. [x] Development
8. [ ] [Examples](./8.EXAMPLES.md)
